#!/usr/bin/env python
"""Measure FUV/NUV+grz+W1-W4 photometry of the MMT HizEA sample.

"""
import matplotlib
matplotlib.use('Agg')

import os, sys, time, pdb
import shutil, argparse
import numpy as np
from astropy.table import Table, hstack
from contextlib import redirect_stdout, redirect_stderr

from astrometry.util.fits import fits_table, merge_tables
from astrometry.util.util import Tan
from legacypipe.survey import LegacySurveyData

#import legacyhalos.io
#import legacyhalos.coadds

from legacyhalos.misc import RADIUS_CLUSTER_KPC, HSC_RADIUS_CLUSTER_KPC

SURVEY_DIR = '/global/project/projectdirs/cosmo/work/legacysurvey/dr8'
HIZEA_DIR = '/global/project/projectdirs/desi/users/ioannis/hizea-lsphot'
HIZEA_CODE_DIR = '/global/u2/i/ioannis/repos/git/hizea'

RADIUS_MOSAIC = 60.0 # [arcsec]

def custom_brickname(ra, dec):
    brickname = '{:06d}{}{:05d}'.format(
        int(1000*ra), 'm' if dec < 0 else 'p',
        int(1000*np.abs(dec)))
    return brickname

def _copyfile(infile, outfile):
    if os.path.isfile(infile):
        os.rename(infile, outfile)
        #shutil.copy2(infile, outfile)
        return 1
    else:
        print('Missing file {}; please check the logfile.'.format(infile))
        return 0

def _ra_ranges_overlap(ralo, rahi, ra1, ra2):
    import numpy as np
    x1 = np.cos(np.deg2rad(ralo))
    y1 = np.sin(np.deg2rad(ralo))
    x2 = np.cos(np.deg2rad(rahi))
    y2 = np.sin(np.deg2rad(rahi))
    x3 = np.cos(np.deg2rad(ra1))
    y3 = np.sin(np.deg2rad(ra1))
    x4 = np.cos(np.deg2rad(ra2))
    y4 = np.sin(np.deg2rad(ra2))
    cw32 = x2*y3 - x3*y2
    cw41 = x1*y4 - x4*y1
    return np.logical_and(cw32 <= 0, cw41 >= 0)

def _galex_rgb_official(imgs, **kwargs):
    from scipy.ndimage.filters import uniform_filter, gaussian_filter
    nuv,fuv = imgs
    h,w = nuv.shape
    red = nuv * 0.206 * 2297
    blue = fuv * 1.4 * 1525
    #blue = uniform_filter(blue, 3)
    blue = gaussian_filter(blue, 1.)
    green = (0.2*blue + 0.8*red)

    red   *= 0.085
    green *= 0.095
    blue  *= 0.08
    nonlinearity = 2.5
    radius = red + green + blue
    val = np.arcsinh(radius * nonlinearity) / nonlinearity
    with np.errstate(divide='ignore', invalid='ignore'):
        red   = red   * val / radius
        green = green * val / radius
        blue  = blue  * val / radius
        mx = np.maximum(red, np.maximum(green, blue))
        mx = np.maximum(1., mx)
    red   /= mx
    green /= mx
    blue  /= mx
    rgb = np.clip(np.dstack((red, green, blue)), 0., 1.)
    return rgb

def _read_galex_tiles(targetwcs, galex_dir, log=None, verbose=False):
    """Find and read the overlapping GALEX FUV/NUV tiles."""

    H, W = targetwcs.shape
    
    ralo, declo = targetwcs.pixelxy2radec(W, 1)
    rahi, dechi = targetwcs.pixelxy2radec(1, H)
    #print('RA',  ralo,rahi)
    #print('Dec', declo,dechi)

    fn = os.path.join(galex_dir, 'galex-images.fits')
    #print('Reading', fn)
    # galex "bricks" (actually just GALEX tiles)
    galex_tiles = fits_table(fn)
    galex_tiles.rename('ra_cent', 'ra')
    galex_tiles.rename('dec_cent', 'dec')
    galex_tiles.rename('have_n', 'has_n')
    galex_tiles.rename('have_f', 'has_f')
    
    cosd = np.cos(np.deg2rad(galex_tiles.dec))
    galex_tiles.ra1 = galex_tiles.ra - 3840*1.5/3600./2./cosd
    galex_tiles.ra2 = galex_tiles.ra + 3840*1.5/3600./2./cosd
    galex_tiles.dec1 = galex_tiles.dec - 3840*1.5/3600./2.
    galex_tiles.dec2 = galex_tiles.dec + 3840*1.5/3600./2.
    bricknames = []
    for tile, subvis in zip(galex_tiles.tilename, galex_tiles.subvis):
        if subvis == -999:
            bricknames.append(tile.strip())
        else:
            bricknames.append('%s_sg%02i' % (tile.strip(), subvis))
    galex_tiles.brickname = np.array(bricknames)

    # bricks_touching_radec_box(self, ralo, rahi, declo, dechi, scale=None):
    I, = np.nonzero((galex_tiles.dec1 <= dechi) * (galex_tiles.dec2 >= declo))
    ok = _ra_ranges_overlap(ralo, rahi, galex_tiles.ra1[I], galex_tiles.ra2[I])
    I = I[ok]
    galex_tiles.cut(I)
    if verbose:
        print('-> bricks', galex_tiles.brickname, flush=True, file=log)

    return galex_tiles

def galex_coadds(onegal, radius_mosaic=RADIUS_MOSAIC, pixscale=1.5, 
                 output_dir=None, galex_dir=None, log=None, verbose=False):
    '''Generate custom GALEX cutouts and perform forced photometry.
    
    radius_mosaic and radius_mask in arcsec
    
    pixscale: GALEX pixel scale in arcsec/pixel.

    '''
    import glob
    import fitsio

    from astrometry.libkd.spherematch import match_radec
    from astrometry.util.resample import resample_with_wcs, OverlapError
    from tractor import (Tractor, NanoMaggies, Image, LinearPhotoCal,
                         NCircularGaussianPSF, ConstantFitsWcs, ConstantSky)

    from legacypipe.survey import imsave_jpeg
    from legacypipe.catalog import read_fits_catalog

    if galex_dir is None:
        galex_dir = os.environ.get('GALEX_DIR')

    galaxy = onegal['galaxy']
    if output_dir is None:
        output_dir = '.'

    W = H = np.ceil(2 * radius_mosaic / pixscale).astype(int) # [pixels]
    targetwcs = Tan(onegal['ra'], onegal['dec'], (W+1) / 2.0, (H+1) / 2.0,
                    -pixscale / 3600.0, 0.0, 0.0, pixscale / 3600.0, float(W), float(H))

    # Read the custom Tractor catalog
    tractorfile = glob.glob(os.path.join(output_dir, '{}-*-tractor.fits'.format(galaxy)))[0]
    if not os.path.isfile(tractorfile):
        print('Missing Tractor catalog {}'.format(tractorfile))
        return 0

    cat = fits_table(tractorfile)
    print('Read {} sources from {}'.format(len(cat), tractorfile), flush=True, file=log)

    srcs = read_fits_catalog(cat)
    for src in srcs:
        src.freezeAllBut('brightness')
    
    # Find all overlapping GALEX tiles and then read the tims.
    galex_tiles = _read_galex_tiles(targetwcs, galex_dir, log=log, verbose=verbose)

    gbands = ['n','f']
    nicegbands = ['NUV', 'FUV']

    zps = dict(n=20.08, f=18.82)

    coimgs, comods, coresids = [], [], []
    for niceband, band in zip(nicegbands, gbands):
        J = np.flatnonzero(galex_tiles.get('has_'+band))
        print(len(J), 'GALEX tiles have coverage in band', band)

        coimg = np.zeros((H, W), np.float32)
        comod = np.zeros((H, W), np.float32)
        cowt  = np.zeros((H, W), np.float32)

        for src in srcs:
            src.setBrightness(NanoMaggies(**{band: 1}))

        for j in J:
            brick = galex_tiles[j]
            fn = os.path.join(galex_dir, brick.tilename.strip(),
                              '%s-%sd-intbgsub.fits.gz' % (brick.brickname, band))
            #print(fn)

            gwcs = Tan(*[float(f) for f in
                         [brick.crval1, brick.crval2, brick.crpix1, brick.crpix2,
                          brick.cdelt1, 0., 0., brick.cdelt2, 3840., 3840.]])
            img = fitsio.read(fn)
            #print('Read', img.shape)

            try:
                Yo, Xo, Yi, Xi, nil = resample_with_wcs(targetwcs, gwcs, [], 3)
            except OverlapError:
                continue

            K = np.flatnonzero(img[Yi, Xi] != 0.)
            if len(K) == 0:
                continue
            Yo, Xo, Yi, Xi = Yo[K], Xo[K], Yi[K], Xi[K]

            wt = brick.get(band + 'exptime')
            coimg[Yo, Xo] += wt * img[Yi, Xi]
            cowt [Yo, Xo] += wt

            x0, x1, y0, y1 = min(Xi), max(Xi), min(Yi), max(Yi)
            subwcs = gwcs.get_subimage(x0, y0, x1-x0+1, y1-y0+1)
            twcs = ConstantFitsWcs(subwcs)
            timg = img[y0:y1+1, x0:x1+1]

            tie = np.ones_like(timg)  ## HACK!
            #hdr = fitsio.read_header(fn)
            #zp = hdr['']
            zp = zps[band]
            photocal = LinearPhotoCal( NanoMaggies.zeropointToScale(zp), band=band)
            tsky = ConstantSky(0.0)
            
            # HACK -- circular Gaussian PSF of fixed size...
            # in arcsec
            #fwhms = dict(NUV=6.0, FUV=6.0)
            # -> sigma in pixels
            #sig = fwhms[band] / 2.35 / twcs.pixel_scale()
            sig = 6.0 / np.sqrt(8 * np.log(2)) / twcs.pixel_scale()
            tpsf = NCircularGaussianPSF([sig], [1.])

            tim = Image(data=timg, inverr=tie, psf=tpsf, wcs=twcs, sky=tsky,
                        photocal=photocal, name='GALEX ' + band + brick.brickname)

            ## Build the model image.
            tractor = Tractor([tim], srcs)
            mod = tractor.getModelImage(0)
            tractor.freezeParam('images')
            tractor.optimize_forced_photometry(priors=False, shared_params=False)
            mod = tractor.getModelImage(0)

            comod[Yo, Xo] += wt * mod[Yi-y0, Xi-x0]

        coimg /= np.maximum(cowt, 1e-18)
        comod /= np.maximum(cowt, 1e-18)

        coresid = coimg - comod

        coimgs.append(coimg)
        comods.append(comod)
        coresids.append(coresid)

        # Write out the final images, making sure to apply the zeropoint to go
        # from counts/s to AB nanomaggies.
        # https://asd.gsfc.nasa.gov/archive/galex/FAQ/counts_background.html
        for thisimg, imtype in zip( (coimg, comod),
                                ('image', 'model') ):
            fitsfile = os.path.join(output_dir, '{}-{}-{}.fits'.format(galaxy, imtype, niceband))
            if verbose:
                print('Writing {}'.format(fitsfile))
            fitsio.write(fitsfile, thisimg * 10**(-0.4 * (zp - 22.5)), clobber=True)

    # Build a color mosaic (but note that the images here are in units of
    # background-subtracted counts/s).

    _galex_rgb = _galex_rgb_official
    for imgs, imtype in zip( (coimgs, comods, coresids),
                             ('image', 'model', 'resid') ):
        rgb = _galex_rgb(imgs)
        jpgfile = os.path.join(output_dir, '{}-{}-FUVNUV.jpg'.format(galaxy, imtype))
        if verbose:
            print('Writing {}'.format(jpgfile))
        imsave_jpeg(jpgfile, rgb, origin='lower')

    return 1
    
def pipeline_coadds(onegal, survey, radius_mosaic=60, nproc=1, pixscale=0.262,
                    run='decam', force=False, cleanup=True, log=None):
    """
    radius_mosaic in arcsec
    
    """
    import subprocess

    galaxy = onegal['galaxy']
    galaxydir = survey.output_dir

    cmd = 'python {legacypipe_dir}/py/legacypipe/runbrick.py '
    cmd += '--radec {ra} {dec} --width {width} --height {width} --pixscale {pixscale} '
    cmd += '--threads {threads} --outdir {outdir} '
    cmd += '--survey-dir {survey_dir} --run {run} '
    #cmd += '--stage image_coadds --early-coadds '
    #cmd += '--write-stage tims '
    cmd += '--write-stage srcs '
    #cmd += '--min-mjd 0 ' # obsolete
    cmd += '--skip-calibs '
    #cmd += '--no-wise-ceres '
    cmd += '--unwise-coadds '
    cmd += '--checkpoint {galaxydir}/{galaxy}-runbrick-checkpoint.p '
    cmd += '--pickle {galaxydir}/{galaxy}-runbrick-%%(stage)s.p '
    
    if force:
        cmd += '--force-all '
        for stage in ('srcs', 'checkpoint'):
            picklefile = os.path.join(survey.output_dir, '{}-runbrick-{}.p'.format(galaxy, stage))
            if os.path.isfile(picklefile):
                os.remove(picklefile)

    width = np.ceil(radius_mosaic / pixscale).astype(int) # [pixels]
    
    cmd = cmd.format(legacypipe_dir=os.getenv('LEGACYPIPE_DIR'), galaxy=galaxy,
                     ra=onegal['ra'], dec=onegal['dec'], width=width,
                     pixscale=pixscale, threads=nproc, outdir=survey.output_dir,
                     galaxydir=galaxydir, survey_dir=survey.survey_dir, run=run)
    print(cmd, flush=True, file=log)
    err = subprocess.call(cmd.split(), stdout=log, stderr=log)

    if err != 0:
        print('Something went wrong; please check the logfile.')
        return 0
    else:
        # Move (rename) files into the desired output directory and clean up.
        brickname = 'custom-{}'.format(custom_brickname(onegal['ra'], onegal['dec']))

        # tractor catalog
        ok = _copyfile(
            os.path.join(survey.output_dir, 'tractor', 'cus', 'tractor-{}.fits'.format(brickname)),
            os.path.join(survey.output_dir, '{}-{}-tractor.fits'.format(galaxy, run)) )
        if not ok:
            return ok

        # CCDs, maskbits, blob images, outlier masks, and depth images
        ok = _copyfile(
            os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                         'legacysurvey-{}-ccds.fits'.format(brickname)),
            os.path.join(survey.output_dir, '{}-ccds.fits'.format(galaxy)) )
        if not ok:
            return ok

        ok = _copyfile(
            os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                         'legacysurvey-{}-maskbits.fits.fz'.format(brickname)),
            os.path.join(survey.output_dir, '{}-maskbits.fits.fz'.format(galaxy)) )
        if not ok:
            return ok

        #ok = _copyfile(
        #    os.path.join(survey.output_dir, 'metrics', 'cus', 'blobs-{}.fits.gz'.format(brickname)),
        #    os.path.join(survey.output_dir, '{}-blobs.fits.gz'.format(galaxy)) )
        #if not ok:
        #    return ok

        ok = _copyfile(
            os.path.join(survey.output_dir, 'metrics', 'cus', 'outlier-mask-{}.fits.fz'.format(brickname)),
            os.path.join(survey.output_dir, '{}-outlier-mask.fits.fz'.format(galaxy)) )
        if not ok:
            return ok

        #for band in ('g', 'r', 'z'):
        #    ok = _copyfile(
        #        os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
        #                     'legacysurvey-{}-depth-{}.fits.fz'.format(brickname, band)),
        #        os.path.join(survey.output_dir, '{}-depth-{}.fits.fz'.format(galaxy, band)) )
        #    if not ok:
        #        return ok
        
        # Data and model images
        for band in ('g', 'r', 'z'):
            for imtype in ('image', 'model'):
                ok = _copyfile(
                    os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                                 'legacysurvey-{}-{}-{}.fits.fz'.format(brickname, imtype, band)),
                    os.path.join(survey.output_dir, '{}-pipeline-{}-{}.fits.fz'.format(galaxy, imtype, band)) )
                if not ok:
                    return ok

        for band in ('g', 'r', 'z'):
            ok = _copyfile(
                os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                             'legacysurvey-{}-invvar-{}.fits.fz'.format(brickname, band)),
                os.path.join(survey.output_dir, '{}-invvar-{}.fits.fz'.format(galaxy, band)) )
            if not ok:
                return ok

        # JPG images

        # Look for WISE stuff in the unwise module--
        for band in ('W1', 'W2', 'W3', 'W4'):
            for imtype in ('image', 'model', 'invvar'):
                ok = _copyfile(
                    os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                                 'legacysurvey-{}-{}-{}.fits.fz'.format(brickname, imtype, band)),
                    os.path.join(survey.output_dir, '{}-{}-{}.fits.fz'.format(galaxy, imtype, band)) )
                if not ok:
                    return ok

        for imtype, suffix in zip(('wise', 'wisemodel'),
                                  ('pipeline-image', 'pipeline-model')):
            ok = _copyfile(
                os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                             'legacysurvey-{}-{}.jpg'.format(brickname, imtype)),
                os.path.join(survey.output_dir, '{}-{}-W1W2.jpg'.format(galaxy, suffix)) )
            if not ok:
                return ok

        for imtype in ('image', 'model', 'resid'):
            ok = _copyfile(
                os.path.join(survey.output_dir, 'coadd', 'cus', brickname,
                             'legacysurvey-{}-{}.jpg'.format(brickname, imtype)),
                os.path.join(survey.output_dir, '{}-pipeline-{}-grz.jpg'.format(galaxy, imtype)) )
            if not ok:
                return ok

        if cleanup:
            shutil.rmtree(os.path.join(survey.output_dir, 'coadd'))
            shutil.rmtree(os.path.join(survey.output_dir, 'metrics'))
            shutil.rmtree(os.path.join(survey.output_dir, 'tractor'))
            shutil.rmtree(os.path.join(survey.output_dir, 'tractor-i'))
            for stage in ('srcs', 'checkpoint'):
                picklefile = os.path.join(survey.output_dir, '{}-runbrick-{}.p'.format(galaxy, stage))
                if os.path.isfile(picklefile):
                    os.remove(picklefile)

        return 1

def read_all_ccds(dr='dr8'):
    """Read the CCDs files, treating DECaLS and BASS+MzLS separately.

    """
    from astrometry.libkd.spherematch import tree_open
    #survey = LegacySurveyData()

    #drdir = os.path.join(legacyhalos.io.sample_dir(), dr)
    drdir = SURVEY_DIR

    kdccds_north = []
    for camera in ('90prime', 'mosaic'):
        ccdsfile = os.path.join(drdir, 'survey-ccds-{}-{}.kd.fits'.format(camera, dr))
        ccds = tree_open(ccdsfile, 'ccds')
        print('Read {} CCDs from {}'.format(ccds.n, ccdsfile))
        kdccds_north.append((ccdsfile, ccds))

    ccdsfile = os.path.join(drdir, 'survey-ccds-decam-{}.kd.fits'.format(dr))
    ccds = tree_open(ccdsfile, 'ccds')
    print('Read {} CCDs from {}'.format(ccds.n, ccdsfile))
    kdccds_south = (ccdsfile, ccds)

    return kdccds_north, kdccds_south

def get_run(onegal, pixscale, kdccds_north, kdccds_south, radius_mosaic=60, log=None):
    """Determine the "run", i.e., determine whether we should use the BASS+MzLS CCDs
    or the DECaLS CCDs file when running the pipeline.

    radius_mosaic in arcsec

    """
    from astrometry.util.util import Tan
    from astrometry.libkd.spherematch import tree_search_radec
    from legacypipe.survey import ccds_touching_wcs
    
    ra, dec = onegal['ra'], onegal['dec']
    if dec < 25:
        run = 'decam'
    elif dec > 40:
        run = '90prime-mosaic'
    else:
        width = np.ceil(radius_mosaic / pixscale).astype(int)
        wcs = Tan(ra, dec, width/2+0.5, width/2+0.5,
                  -pixscale/3600.0, 0.0, 0.0, pixscale/3600.0, 
                  float(width), float(width))
        # BASS+MzLS
        TT = []
        for fn, kd in kdccds_north:
            I = tree_search_radec(kd, ra, dec, 1.0)
            if len(I) == 0:
                continue
            TT.append(fits_table(fn, rows=I))
        if len(TT) == 0:
            inorth = []
        else:
            ccds = merge_tables(TT, columns='fillzero')
            inorth = ccds_touching_wcs(wcs, ccds)
        
        # DECaLS
        fn, kd = kdccds_south
        I = tree_search_radec(kd, ra, dec, 1.0)
        if len(I) > 0:
            ccds = fits_table(fn, rows=I)
            isouth = ccds_touching_wcs(wcs, ccds)
        else:
            isouth = []
            
        if len(inorth) > len(isouth):
            run = '90prime-mosaic'
        else:
            run = 'decam'
        print('Galaxy RA, Dec={:.6f}, {:.6f}: run={} ({} north CCDs, {} south CCDs).'.format(
            ra, dec, run, len(inorth), len(isouth)), flush=True, file=log)

    return run

def check_and_read_ccds(galaxy, survey, debug=False, logfile=None):
    """Read the CCDs file generated by the pipeline coadds step.

    """
    ccdsfile = os.path.join(survey.output_dir, '{}-ccds.fits'.format(galaxy))
    if not os.path.isfile(ccdsfile):
        if debug:
            print('CCDs file {} not found.'.format(ccdsfile), flush=True)
            print('ERROR: galaxy {}; please check the logfile.'.format(galaxy), flush=True)
        else:
            with open(logfile, 'w') as log:
                print('CCDs file {} not found.'.format(ccdsfile), flush=True, file=log)
                print('ERROR: galaxy {}; please check the logfile.'.format(galaxy), flush=True, file=log)
        return False
    survey.ccds = survey.cleanup_ccds_table(fits_table(ccdsfile))

    # Check that coadds in all three grz bandpasses were generated in the
    # previous step.
    if ('g' not in survey.ccds.filter) or ('r' not in survey.ccds.filter) or ('z' not in survey.ccds.filter):
        if debug:
            print('Missing grz coadds...skipping.', flush=True)
            print('ERROR: galaxy {}; please check the logfile.'.format(galaxy), flush=True)
        else:
            with open(logfile, 'w') as log:
                print('Missing grz coadds...skipping.', flush=True, file=log)
                print('ERROR: galaxy {}; please check the logfile.'.format(galaxy), flush=True, file=log)
        return False
    return True

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--nproc', default=1, type=int, help='number of multiprocessing processes per MPI rank.')

    parser.add_argument('--sdss', action='store_true', help='Analyze the SDSS galaxies.')
    parser.add_argument('--first', type=int, default=0, help='Index of first object to process.')
    parser.add_argument('--last', type=int, help='Index of last object to process.')
    parser.add_argument('--coadds', action='store_true', help='Build the pipeline coadds.')
    parser.add_argument('--galex', action='store_true', help='GALEX photometry.')

    parser.add_argument('--pixscale', default=0.262, type=float, help='pixel scale (arcsec/pix).')
    parser.add_argument('--galex-pixscale', default=1.5, type=float, help='GALEX pixel scale (arcsec/pix).')
    parser.add_argument('--sdss-pixscale', default=0.396, type=float, help='SDSS pixel scale (arcsec/pix).')
    
    parser.add_argument('--force', action='store_true', help='Use with --coadds; ignore previous pickle files.')
    parser.add_argument('--count', action='store_true', help='Count how many objects are left to analyze and then return.')

    parser.add_argument('--debug', action='store_true', help='Log to STDOUT and build debugging plots.')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output.')
    parser.add_argument('--clobber', action='store_true', help='Overwrite existing files.')                                
    args = parser.parse_args()

    # Read and broadcast the sample.  For some reason, can't pickle the CCDs
    # files, so have each rank read them (the error is with pickling
    # spherematch).
    samplefile = os.path.join(HIZEA_CODE_DIR, 'etc', 'hizea_sample2.txt')
    sample = Table.read(samplefile, format='ascii.sextractor')
    if args.last is None:
        args.last = len(sample)
        rows = np.arange(args.first, args.last)
    else:
        rows = np.arange(args.first, args.last + 1)
    sample = sample[rows]
    print('Read {} galaxies from {}'.format(len(sample), samplefile))

    if args.coadds:
        kdccds_north, kdccds_south = read_all_ccds()
        survey = LegacySurveyData(survey_dir=SURVEY_DIR)

    for onegal in sample:
        galaxy = onegal['galaxy']
        galaxydir = os.path.join(HIZEA_DIR, 'coadd', galaxy)

        # grzW1-W4 photometry
        if args.coadds:
            checkfile = os.path.join(survey.output_dir, '{}-pipeline-resid-grz.jpg'.format(galaxy))
            if not os.path.exists(checkfile) or args.clobber:
                survey.output_dir = galaxydir
                run = get_run(onegal, args.pixscale, kdccds_north, kdccds_south, radius_mosaic=RADIUS_MOSAIC)
                if args.debug:
                    err = pipeline_coadds(onegal, survey, radius_mosaic=RADIUS_MOSAIC, nproc=args.nproc,
                                          pixscale=args.pixscale, run=run, force=args.force, cleanup=True)
                else:
                    logfile = os.path.join(galaxydir, '{}-coadds.log'.format(galaxy))
                    print('Logging to {} '.format(logfile), flush=True)
                    with open(logfile, 'w') as log:
                        err = pipeline_coadds(onegal, survey, radius_mosaic=RADIUS_MOSAIC, nproc=args.nproc, log=log,
                                              pixscale=args.pixscale, run=run, force=args.force, cleanup=True)
            else:
                print('All done with galaxy {}'.format(galaxy))

        if args.galex:
            if args.debug:
                err = galex_coadds(onegal, radius_mosaic=RADIUS_MOSAIC, pixscale=args.galex_pixscale,
                                   output_dir=galaxydir, verbose=args.verbose)
            else:
                logfile = os.path.join(galaxydir, '{}-galex.log'.format(galaxy))
                print('Logging to {} '.format(logfile), flush=True)
                with open(logfile, 'w') as log:
                    err = galex_coadds(onegal, radius_mosaic=RADIUS_MOSAIC, pixscale=args.galex_pixscale,
                                       output_dir=galaxydir, log=log, verbose=args.verbose)

    ## Determine how many more objects we need to analyze and divide them
    ## across ranks.
    #groups, suffix = [], ''
    #if rank == 0:
    #    suffix, groups = _missing_files(args, sample, size, args.htmldir)
    #
    #if comm:
    #    groups = comm.bcast(groups, root=0)
    #    suffix = comm.bcast(suffix, root=0)
    #
    #if len(groups) == 0:
    #    ntodo = 0
    #else:
    #    ntodo = len(np.hstack(np.atleast_1d(groups)))
    #    
    #if rank == 0:
    #    if ntodo == 0:
    #        print('{} for all {} galaxies are complete!'.format(
    #            suffix.upper(), len(sample)), flush=True)
    #        return
    #    else:
    #        print('{} left to do: {} / {} divided across {} group(s) and {} rank(s).'.format(
    #            suffix.upper(), ntodo, len(sample), len(groups), size), flush=True)
    #
    #if len(groups[rank]) == 0 or args.count:
    #    if len(groups[rank]) > 0 and args.debug:
    #        if args.hsc:
    #            galaxy, galaxydir = legacyhalos.hsc.get_galaxy_galaxydir(sample[groups], htmldir=args.htmldir)
    #        else:
    #            galaxy, galaxydir = legacyhalos.io.get_galaxy_galaxydir(sample[groups], htmldir=args.htmldir)
    #        for ii, dd in zip(groups[rank], galaxydir):
    #            print('  {} {}'.format(ii, dd))
    #        #[print('  {}'.format(dd)) for dd in np.atleast_1d(galaxydir)]
    #    return
    #
    ## Loop on the remaining objects.
    #print('Starting {} {} on rank {} at {}'.format(len(groups[rank]), suffix.upper(),
    #                                               rank, time.asctime()), flush=True)
    #tall = time.time()
    #for count, ii in enumerate(groups[rank]):
    #    onegal = sample[ii]
    #    if args.hsc:
    #        galaxy, galaxydir = legacyhalos.hsc.get_galaxy_galaxydir(onegal, htmldir=args.htmldir)
    #    else:
    #        galaxy, galaxydir = legacyhalos.io.get_galaxy_galaxydir(onegal, htmldir=args.htmldir)
    #    if not os.path.isdir(galaxydir):
    #        os.makedirs(galaxydir, exist_ok=True)
    #
    #    #if (count+1) % 10 == 0:
    #    print('Rank {:03d} ({} / {}): {} (index {})'.format(
    #        rank, count+1, len(groups[rank]), galaxydir, ii), flush=True)
    #
    #    if args.debug:
    #        logfile = None
    #    else:
    #        logfile = os.path.join(galaxydir, '{}-{}.log'.format(galaxy, suffix))
    #        #print('Logging to {} '.format(logfile), flush=True)
    #    
    #    # Need the cluster "radius" to build the coadds.
    #    if args.coadds or args.custom_coadds or args.sky or args.htmlplots:
    #        if args.hsc:
    #            radius_mosaic_arcsec = legacyhalos.misc.cutout_radius_kpc(
    #                redshift=onegal['Z_BEST'], radius_kpc=HSC_RADIUS_CLUSTER_KPC) # [arcsec]
    #        else:
    #            radius_mosaic_arcsec = legacyhalos.misc.cutout_radius_kpc(
    #                redshift=onegal['Z_LAMBDA'], radius_kpc=RADIUS_CLUSTER_KPC) # [arcsec]
    #
    #        survey = LegacySurveyData(survey_dir=SURVEY_DIR)
    #        survey.output_dir = galaxydir
    #
    #    if args.coadds:
    #        if args.sdss:
    #            err = legacyhalos.sdss.download(sample, pixscale=args.sdss_pixscale, clobber=args.clobber)
    #            pdb.set_trace()
    #        else:
    #            _call_pipeline_coadds(onegal, galaxy, radius_mosaic_arcsec, survey,
    #                                  kdccds_north, kdccds_south, args.pixscale,
    #                                  args.nproc, args.force, args.debug, args.hsc,
    #                                  logfile)
    #                
    #                
    #if rank == 0:
    #    print('Finished {} {} at {} after {:.3f} minutes'.format(
    #        ntodo, suffix.upper(), time.asctime(), (time.time() - tall) / 60 ), flush=True)
    #    groups = missing_files(sample, filetype=suffix, size=size, hsc=args.hsc, clobber=args.clobber)
    #    if len(groups) > 0:
    #        stilltodo = len(np.hstack(np.atleast_1d(groups)))
    #    else:
    #        stilltodo = 0
    #    print('{} left to do: {} / {}.'.format(suffix.upper(), stilltodo, ntodo), flush=True)

if __name__ == '__main__':
    main()
